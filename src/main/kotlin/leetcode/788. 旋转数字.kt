package leetcode

/*
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。
如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？

示例：
输入: 10
输出: 4
解释:
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。

提示：
N 的取值范围是 [1, 10000]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotated-digits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
/**
 * 分析：
 * 1.旋转后任是一个数 -> 0,1,8
 * 2.旋转后成另一个数 -> 2,5,6,9
 * 3.不能旋转 -> 3,4,7
 *
 * dp[i] > 0  表示i是好数  （全由0,1,8,2,5,6,9组成）且至少有一个2,5,6,9
 * dp[i] == 0  表示i是中立数 （全由0,1,8组成）
 * dp[i] < 0  表示i是坏数  （包含3,4,7）
 *
 * 因为题目规定了数字范围为[1, 10000]
 * 为了构造合适的转移矩阵，可以将dp的前10个数初始化为
 *
 * 0,1,8 -> 0 -> 中立数加好数为好数
 * 2,5,6,9 -> 1 -> 好数加好数或中立数为好数
 * 3,4,7 -> -9 -> 坏数加好数或中立数为坏数
 *
 * dp[i] = dp[i % 10] + dp[i / 10]
 */
private fun rotatedDigits(N: Int): Int {
    if (N <= 10) {
        var res = 0
        for (i in 1..N) {
            when (i) {
                2, 5, 6, 9 -> res++
            }
        }
        return res
    }
    val dp = IntArray(N + 1).apply {
        this[2] = 1
        this[5] = 1
        this[6] = 1
        this[9] = 1
        this[3] = -9
        this[4] = -9
        this[7] = -9
    }
    var res = 4
    for (i in 10..N) {
        dp[i] = dp[i % 10] + dp[i / 10]
        if (dp[i] > 0) res++
    }
    return res
}

fun main() {
    println(rotatedDigits(10))
    println(rotatedDigits(50))
}